<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Base Cube Game - Win $BASE</title>
  <style>
    /* Your existing CSS styles remain the same */
    /* Add these new styles for wallet connection */
    
    .wallet-section {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
    }
    
    .connect-btn {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, #0052FF 0%, #0070FF 100%);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(0, 82, 255, 0.4);
      transition: all 0.3s ease;
    }
    
    .connect-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 25px rgba(0, 82, 255, 0.6);
    }
    
    .wallet-info {
      background: rgba(0, 82, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 15px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: white;
      font-size: 14px;
    }
    
    .balance {
      font-weight: 600;
      margin-top: 5px;
      color: #00FF88;
    }
    
    .transaction-status {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 82, 255, 0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-weight: 600;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }
  </style>
</head>
<body>
  <!-- Wallet Connection Section -->
  <div class="wallet-section">
    <button class="connect-btn" id="connectBtn">Connect Wallet</button>
    <div class="wallet-info" id="walletInfo" style="display: none;">
      <div>Connected: <span id="walletAddress"></span></div>
      <div class="balance">Balance: <span id="balance">0</span> BASE</div>
    </div>
  </div>

  <!-- Your existing game HTML remains the same -->
  <div class="rewards-table">
    <h3>Rewards</h3>
    <div class="reward-item">
      <span class="reward-symbol">‚≠ê</span>
      <span class="reward-text">1 base token</span>
      <span class="reward-tokens">+1</span>
    </div>
    <div class="reward-item">
      <span class="reward-symbol">üíé</span>
      <span class="reward-text">3 base tokens</span>
      <span class="reward-tokens">+3</span>
    </div>
    <div class="reward-item">
      <span class="reward-symbol">üèÜ</span>
      <span class="reward-text">5 base tokens</span>
      <span class="reward-tokens">+5</span>
    </div>
  </div>

  <div class="game-container">
    <div class="scene">
      <div class="cube" id="cube">
        <div class="face front">üèÜ</div>
        <div class="face back">‚ùå</div>
        <div class="face right">‚ùå</div>
        <div class="face left">‚≠ê</div>
        <div class="face top">üíé</div>
        <div class="face bottom">‚ùå</div>
      </div>
    </div>
    <button class="roll-btn" id="rollBtn">ROLL (Cost: 0.001 ETH)</button>
  </div>

  <div class="pixel-bg" id="pixelBg"></div>
  <div class="firework" id="firework"></div>

  <!-- Add Ethereum and Viem libraries -->
  <script src="https://cdn.ethers.io/lib/ethers-5.7.umd.min.js"></script>
  <script>
    // Base Sepolia Testnet Configuration
    const BASE_SEPOLIA_CHAIN_ID = '0x14a34';
    const BASE_SEPOLIA_RPC = 'https://sepolia.base.org';
    const BASE_TOKEN_ADDRESS = '0x4200000000000000000000000000000000000006'; // WETH on Base Sepolia
    const GAME_COST = ethers.utils.parseEther('0.001'); // 0.001 ETH cost per roll
    const REWARDS = {
      '‚≠ê': ethers.utils.parseEther('1'),  // 1 BASE
      'üíé': ethers.utils.parseEther('3'),  // 3 BASE
      'üèÜ': ethers.utils.parseEther('5')   // 5 BASE
    };

    let provider;
    let signer;
    let userAddress;
    let isConnected = false;

    // DOM Elements
    const connectBtn = document.getElementById('connectBtn');
    const walletInfo = document.getElementById('walletInfo');
    const walletAddress = document.getElementById('walletAddress');
    const balanceElement = document.getElementById('balance');
    const rollBtn = document.getElementById('rollBtn');

    // Initialize provider
    if (typeof window.ethereum !== 'undefined') {
      provider = new ethers.providers.Web3Provider(window.ethereum);
    } else {
      alert('Please install MetaMask to play this game!');
      connectBtn.disabled = true;
      rollBtn.disabled = true;
    }

    // Connect Wallet
    async function connectWallet() {
      try {
        // Request account access
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // Check if connected to Base Sepolia
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        
        if (chainId !== BASE_SEPOLIA_CHAIN_ID) {
          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: BASE_SEPOLIA_CHAIN_ID }],
            });
          } catch (switchError) {
            // If chain doesn't exist, add it
            if (switchError.code === 4902) {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: BASE_SEPOLIA_CHAIN_ID,
                  chainName: 'Base Sepolia',
                  rpcUrls: [BASE_SEPOLIA_RPC],
                  nativeCurrency: {
                    name: 'Ethereum',
                    symbol: 'ETH',
                    decimals: 18
                  },
                  blockExplorerUrls: ['https://sepolia.basescan.org']
                }]
              });
            }
          }
        }

        // Get signer
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        
        // Update UI
        connectBtn.style.display = 'none';
        walletInfo.style.display = 'block';
        walletAddress.textContent = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
        
        await updateBalance();
        isConnected = true;
        
        // Enable roll button
        rollBtn.disabled = false;
        
        showTransactionStatus('Wallet connected successfully!');
        
      } catch (error) {
        console.error('Error connecting wallet:', error);
        showTransactionStatus('Error connecting wallet');
      }
    }

    // Update user balance
    async function updateBalance() {
      if (!signer) return;
      
      try {
        const balance = await signer.getBalance();
        const balanceInEth = ethers.utils.formatEther(balance);
        balanceElement.textContent = parseFloat(balanceInEth).toFixed(4);
      } catch (error) {
        console.error('Error updating balance:', error);
      }
    }

    // Send rewards to user
    async function sendRewards(amount, symbol) {
      if (!signer) return;
      
      try {
        showTransactionStatus(`Sending ${symbol} reward...`);
        
        // In a real game, you'd have a smart contract to handle this
        // For demo purposes, we'll simulate the transaction
        const tx = {
          to: userAddress,
          value: amount
        };
        
        const transaction = await signer.sendTransaction(tx);
        showTransactionStatus('Transaction submitted...');
        
        await transaction.wait();
        showTransactionStatus(`üéâ You won ${ethers.utils.formatEther(amount)} BASE!`);
        
        // Update balance
        await updateBalance();
        
      } catch (error) {
        console.error('Error sending rewards:', error);
        showTransactionStatus('Error sending rewards');
      }
    }

    // Check if user has enough balance
    async function hasEnoughBalance() {
      if (!signer) return false;
      
      try {
        const balance = await signer.getBalance();
        return balance.gte(GAME_COST);
      } catch (error) {
        console.error('Error checking balance:', error);
        return false;
      }
    }

    // Show transaction status
    function showTransactionStatus(message) {
      // Remove existing status
      const existingStatus = document.querySelector('.transaction-status');
      if (existingStatus) {
        existingStatus.remove();
      }
      
      const status = document.createElement('div');
      status.className = 'transaction-status';
      status.textContent = message;
      document.body.appendChild(status);
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        if (status.parentNode) {
          status.remove();
        }
      }, 5000);
    }

    // Modified spinCube function with Web3 integration
    async function spinCube() {
      if (!isConnected) {
        showTransactionStatus('Please connect your wallet first!');
        return;
      }
      
      if (isSpinning) return;
      
      // Check balance
      if (!(await hasEnoughBalance())) {
        showTransactionStatus('Insufficient balance for game cost (0.001 ETH)');
        return;
      }
      
      isSpinning = true;
      rollBtn.disabled = true;
      
      // Pay game cost (simulated - in real implementation, this would go to contract)
      try {
        showTransactionStatus('Paying game fee...');
        // Simulate fee deduction - in real game this would be a contract call
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error('Error paying fee:', error);
        showTransactionStatus('Error processing payment');
        isSpinning = false;
        rollBtn.disabled = false;
        return;
      }

      // Your existing spin animation code
      const startX = Math.random() * 360;
      const startY = Math.random() * 360;
      const finalPos = stopPositions[Math.floor(Math.random() * stopPositions.length)];
      
      let startTime = null;
      const totalDuration = 4000;
      const spinDuration = 3000;
      
      function animate(currentTime) {
        if (!startTime) startTime = currentTime;
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / totalDuration, 1);
        
        if (progress < 0.75) {
          const spinProgress = Math.min(elapsed / spinDuration, 1);
          const easeOut = 1 - Math.pow(1 - spinProgress, 3);
          
          const currentX = startX + (720 * easeOut);
          const currentY = startY + (720 * easeOut);
          
          cube.style.transform = `rotateX(${currentX}deg) rotateY(${currentY}deg)`;
        } else {
          const slowProgress = (progress - 0.75) / 0.25;
          const easeInOut = slowProgress < 0.5 ? 
            2 * slowProgress * slowProgress : 
            1 - Math.pow(-2 * slowProgress + 2, 2) / 2;
          
          const currentX = finalPos.x * easeInOut;
          const currentY = finalPos.y * easeInOut;
          
          cube.style.transform = `rotateX(${currentX}deg) rotateY(${currentY}deg)`;
        }
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          cube.style.transform = `rotateX(${finalPos.x}deg) rotateY(${finalPos.y}deg)`;
          
          const isWinSymbol = winSymbols.includes(finalPos.symbol);
          
          if (isWinSymbol) {
            const faces = cube.getElementsByClassName('face');
            for (let face of faces) {
              if (face.textContent === finalPos.symbol) {
                face.classList.add('win-glow');
                
                // Send rewards based on symbol
                const rewardAmount = REWARDS[finalPos.symbol];
                sendRewards(rewardAmount, finalPos.symbol);
                
                createVictoryFireworks();
                
                setTimeout(() => {
                  face.classList.remove('win-glow');
                }, 2000);
                break;
              }
            }
          } else {
            showTransactionStatus('Better luck next time! ‚ùå');
          }
          
          isSpinning = false;
          rollBtn.disabled = false;
          updateBalance();
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Event Listeners
    connectBtn.addEventListener('click', connectWallet);
    rollBtn.addEventListener('click', spinCube);

    // Listen for account changes
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', (accounts) => {
        if (accounts.length === 0) {
          // User disconnected wallet
          connectBtn.style.display = 'block';
          walletInfo.style.display = 'none';
          isConnected = false;
          rollBtn.disabled = true;
        } else {
          // Account changed
          userAddress = accounts[0];
          walletAddress.textContent = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
          updateBalance();
        }
      });

      window.ethereum.on('chainChanged', (chainId) => {
        if (chainId === BASE_SEPOLIA_CHAIN_ID) {
          updateBalance();
        } else {
          showTransactionStatus('Please switch to Base Sepolia network');
        }
      });
    }

    // Your existing pixel background and firework code remains the same
    const pixelBg = document.getElementById('pixelBg');
    const pixelCount = 1600;
    
    for (let i = 0; i < pixelCount; i++) {
      const pixel = document.createElement('div');
      pixel.classList.add('pixel');
      const animationDelay = Math.random() * 15;
      const animationDuration = 10 + Math.random() * 8;
      pixel.style.animationDelay = `${animationDelay}s`;
      pixel.style.animationDuration = `${animationDuration}s`;
      pixelBg.appendChild(pixel);
    }

    const cube = document.getElementById('cube');
    const firework = document.getElementById('firework');
    
    let isSpinning = false;
    const winSymbols = ['‚≠ê', 'üíé', 'üèÜ'];
    const stopPositions = [
      { x: 0, y: 0, z: 0, symbol: 'üèÜ' },
      { x: 0, y: 180, z: 0, symbol: '‚ùå' },
      { x: 90, y: 0, z: 0, symbol: '‚ùå' },
      { x: -90, y: 0, z: 0, symbol: '‚ùå' },
      { x: 0, y: 90, z: 0, symbol: 'üíé' },
      { x: 0, y: -90, z: 0, symbol: '‚≠ê' }
    ];

    // Your existing createFirework and createVictoryFireworks functions remain the same
    function createFirework(x, y) {
      const colors = ['#0052FF', '#0070FF', '#FFFFFF', '#0088FF', '#E6F0FF', '#B3D4FF'];
      
      for (let i = 0; i < 60; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 80 + Math.random() * 120;
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance;
        const color = colors[Math.floor(Math.random() * colors.length)];
        const size = 3 + Math.random() * 4;
        const duration = 1 + Math.random() * 0.5;
        
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.background = color;
        particle.style.setProperty('--tx', `${tx}px`);
        particle.style.setProperty('--ty', `${ty}px`);
        particle.style.animationDuration = `${duration}s`;
        
        firework.appendChild(particle);
        
        setTimeout(() => {
          particle.remove();
        }, duration * 1000);
      }
    }
    
    function createVictoryFireworks() {
      const positions = [
        [window.innerWidth * 0.1, window.innerHeight * 0.1],
        [window.innerWidth * 0.9, window.innerHeight * 0.1],
        [window.innerWidth * 0.1, window.innerHeight * 0.9],
        [window.innerWidth * 0.9, window.innerHeight * 0.9],
        [window.innerWidth * 0.5, window.innerHeight * 0.1],
        [window.innerWidth * 0.5, window.innerHeight * 0.9],
        [window.innerWidth * 0.1, window.innerHeight * 0.5],
        [window.innerWidth * 0.9, window.innerHeight * 0.5],
        [window.innerWidth * 0.3, window.innerHeight * 0.3],
        [window.innerWidth * 0.7, window.innerHeight * 0.3],
        [window.innerWidth * 0.3, window.innerHeight * 0.7],
        [window.innerWidth * 0.7, window.innerHeight * 0.7]
      ];
      
      positions.forEach(([x, y], index) => {
        setTimeout(() => {
          createFirework(x, y);
        }, index * 150);
      });
    }

    // Your existing window load animation remains the same
    window.addEventListener('load', () => {
      cube.style.opacity = '0';
      cube.style.transform = 'rotateX(15deg) rotateY(15deg) scale(0.8)';
      
      setTimeout(() => {
        cube.style.transition = 'all 1.2s ease-out';
        cube.style.opacity = '1';
        cube.style.transform = 'rotateX(15deg) rotateY(15deg) scale(1)';
      }, 300);
    });
  </script>
</body>
</html>